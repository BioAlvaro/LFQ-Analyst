
matrixplot_modify<-function(data, mapping, pts=list(), smt=list(), ...){
    ggplot(data = data, mapping = mapping, ...) + 
        do.call(geom_point, pts) +
        do.call(geom_smooth, smt) 
}


LFQ_wrapper<-function(maxquant_data,expdesign){
  
  ### Import input MaxQuant proteinGroups.txt file
  maxquant_output<- maxquant_data
  
  ## Optional experimental structure file
  exp_design <- expdesign
  
  ######========= DATA PREPROCESSING =========#######
  # Filter proteins by removing
  # 1. Reverse sequences
  # 2. Potential contaminants
  # 3. Proteins only identified by sites
  # 4. Proteins identified by single peptide
  data <- maxquant_output %>% 
    dplyr:::filter(Reverse!="+", Only.identified.by.site!="+", Razor...unique.peptides>=2)
  
  ## Make data unique by combining  gene names and protein ids in rows where either of them is absent
  data_unique<- DEP:::make_unique(data,"Gene.names","Protein.IDs",delim=";")
  
  #####======= Gnerating Summerised Experiment Object for differential expression analysis =======######
  
  ## get the location of LFQ intensity columns
  lfq_columns<-grep("LFQ.", colnames(data_unique))
  
  ## Convert the protein dataframe into Summerised experiment object for further analysis
  data_se<-DEP:::make_se(data_unique,lfq_columns,exp_design)
  
  
  ## Remove the rows with lot of missing values
  ## This is important step and depends of "thr" option
  ## If thr=0, it means all the replicates in each sample should have valid values, no missing values is allowed
  ## thr=1 means atleast 2 out 3 replicates should have valid values in each sample 
  data_filter<-DEP:::filter_missval(data_se, thr = 1)
  
  # meanSdPlot(data_filter) This can be optional
  
  ######============== Normalisation ===========########
  ## This function uses variance stabilizing transofmation (vsn) function for background correction 
  ## Not much useful for proteomics datasets
  data_norm<-DEP:::normalize_vsn(data_filter)
  #meanSdPlot(data_norm)# Can be optional
  
  ######================ MISSING VALUE IMPUTATION ===============##########
  ## As for this dataset protein intensity plot indicated that proteins with missing value have on average low intensities,
  ## I choose missing value imputation to be one of MNAR method 
  ## Following code will impute missing value with algorithm similar to perseus
  ## i.e. random values drawn from normal distribution of 1.8 SD apart with the width of 0.3
  data_imp_man<-DEP:::impute(data_filter,fun="man",shift=1.8,scale=0.3)
  

  ######============= DIFFERENTIAL EXPRESSION ANALYSIS ============###########
  
  ## This test uses protein-wise linear model with emperical Bayes statistics (used in R package limma)
  ## Limma is modified version of t-test and widely used for transcriptomics analysis
  ## Number of different options available such as "all", "control" and "man" to compare various conditions
  ## "all"- compares all pairwise comparisons
  ## "control"- asks to specify the control sample and compares every other sample against control
  ## "man"- manually specify which condition to test 
  
  #data_diff_all_contrasts<-test_diff(data_imp_man,type='all')
  # If the data has multiple pairwise comparisions we need to generate volcano plot for each comparison
  # "comparison" is a character vectors that stores the name of all comparison and captured from
  #  the message generated by "test_diff" function
  # Example of message "Tested_contrasts: "Control_vs_Condition1", "Control_vs_Condition2""
  comparisons<-capture.output(data_diff_all_contrasts<-test_diff(data_imp_man,type='all'),type = "message")
  
  ## Remove "Tested contrasts:"
  comparisons<-gsub(".*: ","",comparisons)
  ## Split conditions into character vector
  comparisons<-unlist(strsplit(comparisons,","))
  ## Remove leading and trailing spaces
  comparisons<-trimws(comparisons)
  
  ## Mark significantly different proteins
  ## Input needed to define the threshold
  ## "alpha"- adjusted p-value cutoff
  ## "lfc"- log2(Fold Change) cutoff
  alpha<- 0.05
  lfc<- 1
  param<- data.frame(alpha, lfc)
  dep<-DEP:::add_rejections(data_diff_all_contrasts,alpha = 0.05,lfc = log2(1))
  

  ## Plot multiple scatterplots
  ## First get the LFQ expression data
  ## Use ggpairs function from GGally library to generate multiple matrix plots
  paired_data<-as.data.frame(assay(dep))
  

  
  
  ######=============== ENRICHMENT ANALYSIS ============== ##########
  ## Protein Set Enrichment Analysis is based on EnrichR
  ## Need to specify the databases to perform enrichment test
  
  ## Gene Ontology Enrichment
 # gsea_results_GO <- test_gsea(dep)
  
  
  ## KEGG enrichment
 # results_kegg<- test_gsea(dep,databases = c("KEGG_2016"))
  
  
  ####=============== Write Results ===========#######
  data_result<-get_results(dep)
  # write.csv(data_result,"LFQ_results.csv",row.names = FALSE)
  
 save.image (file="data/lfq_results.RData")
return(dep)
  
}

# get_pdf_plot<-function(type_of_plot){
#   pdf(paste0(type_of_plot,".pdf",sep="")
#       plot(type_of_plot)
#       dev.off()
# }

coef_variation<-function(x){
  coef=sd(x)/mean(x)
}

#### Plot CVs

plot_cvs<-function(se) {
  
  ## backtransform data
  untransformed_intensity<- 2^(assay(se))
  exp_design<-colData(se)

### merge untransformed to exp design and calculate cvs
  
  cvs_group<- untransformed_intensity %>% data.frame() %>%
    tibble::rownames_to_column() %>%
    tidyr::gather("ID", "Intensity", -rowname) %>%
    dplyr::left_join(.,data.frame(exp_design), by="ID") %>%
    dplyr::group_by(rowname,condition) %>%
    dplyr::summarise(cvs=coef_variation(Intensity)) %>%
    dplyr::group_by(condition)%>%
    dplyr::mutate(condition_median=median(cvs))
  
p1 <-  ggplot(cvs_group, aes(cvs, color=condition, fill=condition)) +
    geom_histogram(alpha=.5, bins= 20, show.legend = FALSE) +
    facet_wrap(~condition) +
    geom_vline(aes(xintercept=condition_median, group=condition),color='grey40',
             linetype="dashed") +
    labs(title= 'Sample Coefficient of Variation', x="Coefficient of Variation", y="Count") +
    theme_DEP2() +
    theme(plot.title = element_text(hjust = 0.5,face = "bold")) 
p1 +geom_text(aes(x=max(cvs_group$cvs)-0.6,
                  y=max(ggplot_build(p1)$data[[1]]$ymax*1.1), 
                  label=paste0("Median =",round(condition_median,2)*100,"%",by="")),
              show.legend = FALSE, size=4)
}


#### Get individual clusters from heatmap
get_cluster_heatmap <- function(dep, type = c("contrast", "centered"),
                                kmeans = FALSE, k = 6,
                                col_limit = 6, indicate = NULL,
                                clustering_distance = c("euclidean", "maximum", "manhattan", "canberra",
                                                        "binary", "minkowski", "pearson", "spearman", "kendall", "gower"),
                                row_font_size = 6, col_font_size = 10, plot = TRUE, ...) {
  
  # Show error if inputs are not the required classes
  if(is.integer(k)) k <- as.numeric(k)
  if(is.integer(col_limit)) col_limit <- as.numeric(col_limit)
  if(is.integer(row_font_size)) row_font_size <- as.numeric(row_font_size)
  if(is.integer(col_font_size)) col_font_size <- as.numeric(col_font_size)
  assertthat::assert_that(inherits(dep, "SummarizedExperiment"),
                          is.character(type),
                          is.logical(kmeans),
                          is.numeric(k),
                          length(k) == 1,
                          is.numeric(col_limit),
                          length(col_limit) == 1,
                          is.numeric(row_font_size),
                          length(row_font_size) == 1,
                          is.numeric(col_font_size),
                          length(col_font_size) == 1,
                          is.logical(plot),
                          length(plot) == 1)
  
  # Show error if inputs do not contain required columns
  type <- match.arg(type)
  clustering_distance <- match.arg(clustering_distance)
  
  # Extract row and col data
  row_data <- rowData(dep)
  col_data <- colData(dep) %>%
    as.data.frame()
  
  # Show error if inputs do not contain required columns
  if(any(!c("label", "condition", "replicate") %in% colnames(col_data))) {
    stop(paste0("'label', 'condition' and/or 'replicate' columns are not present in '",
                deparse(substitute(dep)), "'"),
         call. = FALSE)
  }
  if(length(grep("_diff", colnames(row_data))) < 1) {
    stop(paste0("'[contrast]_diff' columns are not present in '",
                deparse(substitute(dep)),
                "'.\nRun test_diff() to obtain the required columns."),
         call. = FALSE)
  }
  if(!"significant" %in% colnames(row_data)) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(dep)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }
  
  # Heatmap annotation
  if(!is.null(indicate) & type == "contrast") {
    warning("Heatmap annotation only applicable for type = 'centered'",
            call. = FALSE)
  }
  if(!is.null(indicate) & type == "centered") {
    ha1 <- get_annotation(dep, indicate)
  } else {
    ha1 <- NULL
  }
  
  # Filter for significant proteins only
  filtered <- dep[row_data$significant, ]
  
  # Check for missing values
  if(any(is.na(assay(filtered)))) {
    warning("Missing values in '", deparse(substitute(dep)), "'. ",
            "Using clustering_distance = 'gower'",
            call. = FALSE)
    clustering_distance <- "gower"
    obs_NA <- TRUE
  } else {
    obs_NA <- FALSE
  }
  
  # Get centered intensity values ('centered')
  if(type == "centered") {
    rowData(filtered)$mean <- rowMeans(assay(filtered), na.rm = TRUE)
    df <- assay(filtered) - rowData(filtered)$mean
  }
  # Get contrast fold changes ('contrast')
  if(type == "contrast") {
    df <- rowData(filtered) %>%
      data.frame() %>%
      column_to_rownames(var = "name") %>%
      select(ends_with("_diff"))
    colnames(df) <-
      gsub("_diff", "", colnames(df)) %>%
      gsub("_vs_", " vs ", .)
  }
  
  # Facultative kmeans clustering
  if(kmeans & obs_NA) {
    warning("Cannot perform kmeans clustering with missing values",
            call. = FALSE)
    kmeans <- FALSE
  }
  if(kmeans & !obs_NA) {
    set.seed(1)
    df_kmeans <- kmeans(df, k)
    if(type == "centered") {
      # Order the k-means clusters according to the maximum fold change
      # in all samples averaged over the proteins in the cluster
      order <- data.frame(df) %>%
        cbind(., cluster = df_kmeans$cluster) %>%
        dplyr::mutate(row = apply(.[, seq_len(ncol(.) - 1)], 1, function(x) max(x))) %>%
        dplyr::group_by(cluster) %>%
        dplyr::summarize(index = sum(row)/n()) %>%
        dplyr::arrange(desc(index)) %>%
        dplyr::pull(cluster) %>%
        match(seq_len(k), .)
      df_kmeans$cluster <- order[df_kmeans$cluster]
    }
    if(type == "contrast") {
      # Order the k-means clusters according to their average fold change
      order <- cbind(df, cluster = df_kmeans$cluster) %>%
        dplyr::gather(condition, diff, -cluster) %>%
        dplyr::group_by(cluster) %>%
        dplyr::summarize(row = mean(diff)) %>%
        dplyr::arrange(desc(row)) %>%
        dplyr::pull(cluster) %>%
        match(seq_len(k), .)
      df_kmeans$cluster <- order[df_kmeans$cluster]
    }
  }
  
  if(ncol(df) == 1) {
    col_clust = FALSE
  } else {
    col_clust = TRUE
  }
  if(nrow(df) == 1) {
    row_clust = FALSE
  } else {
    row_clust = TRUE
  }
  if(clustering_distance == "gower") {
    clustering_distance <- function(x) {
      dist <- cluster::daisy(x, metric = "gower")
      dist[is.na(dist)] <- max(dist, na.rm = TRUE)
      return(dist)
    }
  }
  
  # Legend info
  legend <- ifelse(type == "contrast",
                   "log2 Fold change",
                   "log2 Centered intensity")
  
  # Heatmap
  ht1 = Heatmap(df,
                col = circlize::colorRamp2(
                  seq(-col_limit, col_limit, (col_limit/5)),
                  rev(RColorBrewer::brewer.pal(11, "RdBu"))),
                split = if(kmeans) {df_kmeans$cluster} else {NULL},
                cluster_rows = col_clust,
                cluster_columns = row_clust,
                row_names_side = "left",
                column_names_side = "top",
                clustering_distance_rows = clustering_distance,
                clustering_distance_columns = clustering_distance,
                heatmap_legend_param = list(color_bar = "continuous",
                                            legend_direction = "horizontal",
                                            legend_width = unit(5, "cm"),
                                            title_position = "lefttop"),
                name = legend,
                row_names_gp = gpar(fontsize = row_font_size),
                column_names_gp = gpar(fontsize = col_font_size),
                top_annotation = ha1,
                ...)
  # return (row_order(ht1))
  # Return data.frame
  draw(ht1, heatmap_legend_side = "top")
  row_clusters<- row_order(ht1)
  #mat<-as.matrix(df)
  
  # for (i in 1:length(row_clusters)){
  #   if (i==1){
  #     clu <-t(t(row.names(ht1[row_clusters[[i]],])))
  #     out <-cbind (clu, paste("cluster", i, sep=""))
  #     colnames(out)<- c("ProteinID", "Cluster")
  #   }
  #   else{
  #     clu <- t(t(row.names(ht1[row_clusters[[i]],])))
  #     clu <- cbind(clu, paste("cluster", i, sep = ""))
  #     out <- cbind(out, clu)
  #   }
  # }
  return(row_clusters)
}

# Internal function to get ComplexHeatmap::HeatmapAnnotation object
get_annotation <- function(dep, indicate) {
  assertthat::assert_that(
    inherits(dep, "SummarizedExperiment"),
    is.character(indicate))
  
  # Check indicate columns
  col_data <- colData(dep) %>%
    as.data.frame()
  columns <- colnames(col_data)
  if(all(!indicate %in% columns)) {
    stop("'",
         paste0(indicate, collapse = "' and/or '"),
         "' column(s) is/are not present in ",
         deparse(substitute(dep)),
         ".\nValid columns are: '",
         paste(columns, collapse = "', '"),
         "'.",
         call. = FALSE)
  }
  if(any(!indicate %in% columns)) {
    indicate <- indicate[indicate %in% columns]
    warning("Only used the following indicate column(s): '",
            paste0(indicate, collapse = "', '"),
            "'")
  }
  
  # Get annotation
  anno <- dplyr::select(col_data, indicate)
  
  # Annotation color
  names <- colnames(anno)
  anno_col <- vector(mode="list", length=length(names))
  names(anno_col) <- names
  for(i in names) {
    var = anno[[i]] %>% unique() %>% sort()
    if(length(var) == 1)
      cols <- c("black")
    if(length(var) == 2)
      cols <- c("orangered", "cornflowerblue")
    if(length(var) < 7 & length(var) > 2)
      cols <- RColorBrewer::brewer.pal(length(var), "Pastel1")
    if(length(var) > 7)
      cols <- RColorBrewer::brewer.pal(length(var), "Set3")
    names(cols) <- var
    anno_col[[i]] <-  cols
  }
  
  # HeatmapAnnotation object
  ComplexHeatmap::HeatmapAnnotation(df = anno,
                    col = anno_col,
                    show_annotation_name = TRUE)
}
